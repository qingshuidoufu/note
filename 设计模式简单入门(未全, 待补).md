





# 设计模式简单入门(未全, 待补)

![image-20210515171436614](images/设计模式简单入门(未全, 待补)/image-20210515171436614.png)

![image-20210515171552259](设计模式简单入门(未全, 待补).assets/image-20210515171552259.png)







## 单例模式

饿汉式/DCL懒汉式

```java
package main.java.com.kuang.single;

public class Hungry {
    //可能会浪费空间(饿汉式,初始化的类的时候一次性把所有对象属性都加载出来)
    private byte[] data1=new byte[1024*1024];
    private byte[] data2=new byte[1024*1024];
    private byte[] data3=new byte[1024*1024];
    private byte[] data4=new byte[1024*1024];

    private  Hungry(){

    }
    private final static Hungry HUNGRY=new Hungry();

    public  static Hungry getInstance(){
        return HUNGRY;
    }
}
```

```java
package main.java.com.kuang.single;

public class LazyMan {
    private LazyMan(){
        System.out.println(Thread.currentThread().getName()+"ok");

    }
    //双重检测锁模式的懒汉式单例 DCL懒汉式
    private volatile static LazyMan lazyMan;
    public static LazyMan getInstance(){
        //加锁
        if(lazyMan==null){
            synchronized (LazyMan.class){
                if(lazyMan==null){
                    lazyMan=new LazyMan(); //不是一个原子性操作
                    /**
                     * 1. 分配内存空间
                     * 2. 执行构造方法初始化对象
                     * 3. 把对象指向这个空间
                     *
                     * 期望: 123
                     * 实际: 132 A
                     * B  此时lazyMan没完成构造,(A B为模拟线程)
                     * 所以必须使用volatile 来避免指令重排的时候多线程模式下出现的问题
                     */
                }
            }
        }

        return lazyMan;
    }
    //单线程下可以,多线程有问题
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                LazyMan.getInstance();
            }).start();
        }
    }
}
```

## 工厂模式

![image-20210516114405210](设计模式简单入门(未全, 待补).assets/image-20210516114405210.png)

![image-20210516114505977](设计模式简单入门(未全, 待补).assets/image-20210516114505977.png)

![image-20210516162449433](设计模式简单入门(未全, 待补).assets/image-20210516162449433.png)

```java
package main.java.com.kuang.factory.simple;

//简单工厂模式(静态工厂模式)
//使用的的是静态方法,接受不同参数生产不同实例
//如果不修改-代码来增加要生产的实例,却不能实现开闭原则
//开闭原则(对外拓展开放, 对修改关闭)
public class CarFactory {
    //方法一
     public static Car getCar(String car){
         if(car.equals("五菱")){
             return new WuLing();
         }else if(car.equals("特斯拉")){
             return new Tesla();
         }else {
             return null;
         }
     }
     //方法二
    public static Car getWuLing(){
         return new WuLing();
    }
    public static Car getTesla(){
         return new Tesla();
    }
    public static Car getDaZong(){
         return new DaZong();
    }
}
```

![image-20210516163440156](设计模式简单入门(未全, 待补).assets/image-20210516163440156.png)

如上图, 如果系统中要新增一台车, 那么务必需要修改车工厂的代码,那么就不符合 **开闭原则	**, 所以, 我们可以将车工厂抽象成为一个接口, 加多一层五菱工厂/tesla工厂/大众工厂去继承车工厂, 最终在工厂模式解耦的情况下情况下去满足 **开闭原则	**(新增车的时候不需要去动车工厂, 而是去新增一个摩拜工厂, 横向去添加功能, 下图)



![image-20210516164930756](设计模式简单入门(未全, 待补).assets/image-20210516164930756.png)

```java
//工厂方法模式
public interface CarFactory {
    Car getCar();
}
```

```java
public class WuLingFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new WuLing();
    }
}
```



简单工厂和工厂方法对比

结构复杂度:simple

代码复杂度: simple

编程复杂度:simple

管理复杂度: simple

结论: 根据**设计原则, 我们需要使用工厂方法模式, 根据实际业务, 采用简单工厂模式**

总结: ![image-20210516165657276](设计模式简单入门(未全, 待补).assets/image-20210516165657276.png)



## 抽象工厂模式

![image-20210516165825292](设计模式简单入门(未全, 待补).assets/image-20210516165825292.png)

下图左边工厂和工厂实现,  右边接口和接口实现

![image-20210516170752564](设计模式简单入门(未全, 待补).assets/image-20210516170752564.png)



![image-20210517083950772](设计模式简单入门(未全, 待补).assets/image-20210517083950772.png)







## 建造者模式

![image-20210516175542014](设计模式简单入门(未全, 待补).assets/image-20210516175542014.png)

```java
public class Worker extends Builder {
    Product product;

    public Worker(){
        product =new Product();
    }
    @Override
    void buildA() {
        product.setBuildA("地基");
        System.out.println("地基");
    }

    @Override
    void buildB() {
        product.setBuildB("钢筋工程");
        System.out.println("钢筋工程");
    }

    @Override
    void buildC() {
        product.setBuildC("铺电线");
        System.out.println("铺电线");
    }

    @Override
    void buildD() {
        product.setBuildD("粉刷");
        System.out.println("粉刷");
    }

    @Override
    Product getProduct() {
        return product;
    }
}
```

```java
//指挥:核心, 负责指挥构建一个工程, 工程如何创建,由他去决定
public class Director {
    //指挥工人按照顺序建房子(指挥其抽象类去指挥工人)
    //如果要更改顺序, 只需要更改指挥者,不用动worker
    //根据worker的类型不同, 可以调用不同的工人建造不一样的楼
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        //指挥
        Director director=new Director();
        //指挥具体工人完成产品
        Product build =director.build(new Worker());
        System.out.println(build.toString());
    }
}
```

![image-20210516202257398](设计模式简单入门(未全, 待补).assets/image-20210516202257398.png)



![image-20210516205306336](设计模式简单入门(未全, 待补).assets/image-20210516205306336.png)

上图,的情况, 就是少了director , 把控制权交给了用户,调用worker的方法去改变构建的方式

![image-20210516211244675](设计模式简单入门(未全, 待补).assets/image-20210516211244675.png)

![image-20210516211630800](设计模式简单入门(未全, 待补).assets/image-20210516211630800.png)

## 代理模式

spring的AOP的底层就是代理模式

### [springAOP] 和[springMVC]是面试必问的

代理的分类:

### 1. 静态代理

![image-20210516234550051](设计模式简单入门(未全, 待补).assets/image-20210516234550051.png)

- 抽象角色: 一般使用接口或者抽象类来解决

  ```java
  package com.kuang.demo01;
  //租房的接口
  public interface Rent {
      public void rent();
  }
  ```

- 真实角色: 被代理的角色

  ```java
  public class Host implements Rent {
      @Override
      public void rent() {
          System.out.println("房东要出租房子");
      }
  }
  ```

- 代理角色: 代理真实角色, 代理真实角色后, 我们一般会做一些附属操作

  ```java
  public class Proxy implements Rent{
      private Host host;
  
      public Proxy(Host host) {
          this.host = host;
      }
  
      public Proxy(){
  
      }
  
      @Override
      public void rent() {
          seeHouse();
          host.rent();
          hetong();
          fare();
      }
      //看房
      public void seeHouse(){
          System.out.println("中介带你看房");
      }
      //收中介费
      public void fare(){
          System.out.println("收中介费");
      }
      //签租赁合同
      public void hetong(){
          System.out.println("签租赁合同");
      }
  }
  ```

- 客户: 访问代理对象的人

- ```java
  public class Client {
      public static void main(String[] args) {
          //房东要租房子
          Host host=new Host();
         //代理, 代理帮房东租房子, 但是代理会一般会有一些附属操作
          Proxy proxy =new Proxy(host);
          //你不用面对房东, 直接找中介租房即可
          proxy.rent();
      }
  }
  ```

#### 代理模式的好处: 

1. 可以让真实角色的操作更加纯粹, 不用关注一些公共的业务

2. 公共业务交给代理角色,实现了业务的分工
3. 公共业务发生拓展的时候, 方便集中管理

#### 代理模式的缺点:

1. 一个真实角色会产生一个代理角色; 代码量会翻倍导致开发效率降低



#### 静态代理加深理解

![image-20210517085325934](设计模式简单入门(未全, 待补).assets/image-20210517085325934.png)

### 2. 动态代理

- 动态代理和静态代理角色一样
- 动态代理的代理类是动态生成的, 不是我们直接写好的
- 动态代理分为两大类: 基于接口的动态代理   基于类的动态代理
  - 基于接口的动态代理-----JDK动态代理[此处介绍的]
  - 基于类: cglib
  - java字节码实现

需要了解两个类:

![image-20210517102506165](设计模式简单入门(未全, 待补).assets/image-20210517102506165.png)

**InvocationHandler: 调用处理程序**

​	InvocationHandler是由代理实例化的调用处理程序的接口, 每个代理实例都有一个关联的调用处理程序. 当在代理实例上调用方法时, 方法调用将编码分派到其调用处理程序的invoke方法.

 	方法: invoke()	: 处理代理实例上的方法调用并且返回结果集

**Proxy:代理类**

​	proxy提供了动态代理类和实例的静态方法, 它也是由这些方法创建的所有动态代理类的超类

​		方法: getInvocationHandler() :返回指定代理实例的调用程序

​				newProxyInstance(): 返回指定接口的代理类实例, 该接口将方法分派给指定的处理程序



ProxyInvocationHandler

```java


//等会我们会用这个类自动生成代理类
public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

    //生成得到代理类
    public Object getProxy(){
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(), this );
    }

    /**
     * 处理代理实例并且返回结果
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        seeHouse();
        //动态代理的本质, 就是使用反射机制来实现
        Object result= method.invoke(rent,args);
        fare();
        return result;
    }
    public void seeHouse(){
        System.out.println("中介带看房子");
    }
    public void fare(){
        System.out.println("收中介费");
    }
}
```

host

```java
public class Host implements Rent {
    @Override
    public void rent() {
        System.out.println("房东要出租房子");
    }
}
```

rent

```java
//租房的接口
public interface Rent {
    public void rent();
}
```

Client

```java
public class Client {
    public static void main(String[] args) {
        //真实角色
        Host host=new Host();
        //代理角色: 现在没有
      ProxyInvocationHandler pih=  new ProxyInvocationHandler(); //实例化一个处理调用程序

      //通过调用程序处理角色, 来处理我们要调用的接口对象
        pih.setRent(host);
        // 拿到代理程序
        Rent  proxy= (Rent)pih.getProxy();  //这里的proxy就是动态生成的, 我们并没有写
        proxy.rent();
    }
}
```



#### 注意:

- ProxyInvocationHandler中的getProxy方法作用就是获得一个该实现了该接口的对象的代理对象, 其传入参数为处理程序的类加载器, 要代理的接口的字节码接口, 当前处理程序 
- ProxyInvocationHandler中的invoke方法的作用相当于拦截真实对象的的方法, 对其真实对象进行切片, 在不改变真实对象的情况下添加操作, 当**调用代理对象的方法时(跟真实对象的方法同名), 由invoke()接管.**

**动态代理的好处:**

 		

1. 可以让真实角色的操作更加纯粹, 不用关注一些公共的业务

2. 公共业务交给代理角色,实现了业务的分工
3. 公共业务发生拓展的时候, 方便集中管理
4. 一个动态代理类代理的是一个接口, 一般就是对应的一类业务
5. 一个动态代理类可以代理多个类, 只要实现了接口就行

​	