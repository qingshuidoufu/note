# 概述

## 什么是信息系统:

- 人/数据/过程和信息技术之间互相作用/收集/处理/存储拓攻企业运作的信息集合体
- 信息系统是软件

## 什么是信息系统分析和设计

- 信息系统分析对业务问题的学习活动,**理解问题域**,免却业务需求提供良好建议
- 信息系统设计是对信息系统分析已确认的业务需求建立一种解决方案(求可行解)

## 软件开发方法

**软件:** 程序/数据/说明文档

​	程序: 设计好的满足功能和性能需求的 **指令序列**
​	数据: 程序能正常操作信息的 **数据结构**
​	文档: 程序开发和维护使用的各种 **图文资料**

### 软件4个发展阶段



1. 程序设计阶段: 除了源代码外没有软件说明书等文档(缺点: 难开发大型软件, 除了本人其他人看不懂)

2. 软件设计阶段: 小组合作生产方式 (缺点: 没有工程化方法指导, 开发成本高,经常失败)

      特征:

   1. 多人分工协作
   2. 多个开发小组承担运行/维护
   3. 软件和硬件相互依存共同发挥作用

**到了第二个阶段后出现了"软件危机"**

**软件危机**: 软件开发和维护出现一系列严重问题, 开发进度难以预测,成品难以保证/用户对功能难以满足,质量无法保证,难维护/缺文档(最著名的是IBM的IBM360操作系统)

3. 软件工程阶段: 开发程序外,还包括编制开发/使用/维护的 **文档**, 软件开发范围从 **需求定义/分析/设计/编码/测试/使用到维护**整个生命周期,

   特征:

   1. 工程化思想
   2. 软件开发成功率提高/质量保证
   3. CASE(compute Aided software Engineering计算机辅助软件和工具工具大量出现

4. 现代软件工程阶段: 20世纪90年代到现在

   特征:

   1. 面向对象技术广泛使用
   2. 软件开发技术组件成熟: 软件复用技术/构建设计技术/分布式计算技术

## 什么是软件工程

针对软件的工程化方法,覆盖软件**生命周期所有阶段,** 提供 **一整套的工程化方法** 来指导开发

软件开发除了 **程序**外, 还包括所需 **文档**

软件工程包括以下两方面:

1. 软件开发技术: 包括软件开发方法学, 软件工具和软件工程环境
2. 软件项目管理: 软件度量/项目估算/进度控制/人员组织/配置管理/项目计划

### 软件工程三要素

1. IEEE界定的软件工程的 **10个知识域**
   1. 软件需求
   2. 软件设计
   3. 软件构建
   4. 软件测试
   5. 软件维护
   6. 软件配置管理
   7. 软件工程管理
   8. 软件工程过程
   9. 软件工程工具和方法
   10. 软件质量

### 软件工程的框架

- 由 **软件工程目标/软件工程活动/软件工程原则** 三个方面构成
  1. 软件工程目标: 开发出有质量和费用合算的产品(生产的正确性/可用性/合算)
  2. 软件工程活动: 需求/设计/实现/确认/支持
     - 需求包括 问题分析(需求获取和定义)/需求分析(软件功能规约)
     - 设计包括 概要设计(整个软件体系结构)/详细设计(程序员可用模块说明)
     - 实现: 把设计结构转换为控制性程序代码
     - 确认: 贯穿整个开发过程,对完成的结果进行确认, 保证满足用户的要求
     - 支持: 修改和完善活动

### 软件工程的原则:

1. 选择合适的 **开发泛型**
2. 采用合适的 **设计方法**
3. 提供高质量的 **工程设计**
4. 重视开发过程的 **管理**

### 软件工程基本原理

1. 分阶段生命周期计划 **严格管理**
2. 坚持使用 **阶段评审**
3. 实行严格的 **产品控制**
4. 采用 **现代程序设计技术**
5. 结构能清晰 **审查**
6. 开发人员 **少而精**
7. 承认不断 **改进** 软件工程时间的必要性



### 软件过程和开发方法

- 软件过程是为了获得高质量的软件完成的一系列任务的框架,规定了文成各项任务的 **工作步骤**

- 软件过程描述了为了开发出客户满意的软件, **什么人, 什么时候,做什么事, 怎么做**来是实现一个特定的具体目标

- 通常用 **生命周期模型**简介描述软件过程, 把生命周期划分为哪个阶段执行顺序, 称为 **软件过程模型**

- 常见 **软件过程模型**

  - 瀑布模型/快速原型/增量模型/螺旋模型/喷泉模型/v模型/智能模型

    **瀑布模型**: 分为软件计划/需求分析/系统设计/软件编写/软件测试/运行维护6个活动, 规定 **自上而下,相互衔接** 的固定次序,如同 **瀑布流水,逐级下落**

    ​	优点: 

    1. 严格规定 **必须提交的文档, 可以强迫使用规范的开发方法**

    2. 给项目提供 **检查点*, **,保证软件的开发质量

    3. 阶段完成后,只需要关注 **后续的阶段**

       缺点:

       1. 产生大量文档,增加工作量
       2. 开发模型线性, 成果未测试, 看不到, 从而**增加风险**
       3. 早期错误可能等到开发后期 **测试阶段**,才能发现, 可能导致 **严重后果, 可能导致项目失败**
       4. 需求阶段, **完全确定需求比较困难**

       **快速原型模型**

       快速建立原型,交给用户使用反馈,然后修改完善,如此迭代

       优点:

       1. 减少 **需求的不确定性**
       2. 更好和客户沟通, 提高客户 **对软件的满意度**
       3. 减少技术/应用风险, 缩成本, **提高产品质量**

        缺点:

       1. 快速建立原型, 可能 **限制开发人员创新**
       2. 所选技术不一定是主流 , **效率低**
       3. 连续修改 可能对吹吹 **产品的设计差**
       4. 客户确定真正需求, **原型可能被抛弃**

       **增量模型(演化模型)**

       1. 整合 **瀑布模型的基本成分和快速原型的迭代特征**

       2. 软件作为一系列 **增量构件** 设计/实现/继承和测试

          每个构件由多个相互作用形成的代码片段, 第一个增量往往是核心

       优点:

       1. 可以 **适应变化**, **降低开发风险**

       缺点:

       1. 需要 **软件具有开放式的体系结构**
       2. 容易退化未边做边改模型,让 **程序过程控制失去整体性**

       **螺旋模型**

       将 **瀑布模型** 和 **快速原型模型** 结合起来, 强调 **风险分析** ,特别适合 **大型复杂系统 **

       优点:

       1. 强调可选方案和约束条件, 支持 **软件重用**
       2. 有助于提高 **软件质量**

       缺点:

       1. 要求客户接收相信风险分析,往往 **使用与大规模软件开发**
       2. 风险分析大大影响项目利润, 则风险分析不合适
       3. 要求软件开发人员擅长找风险, 否则带来 **更大风险**
       4. 不适合 **合同项目的开发**

       **喷泉模型**

       称为 **面向对象生存期模型(OO模型)**, 生存期各阶段 **相互重叠, 多次反复**, 在项目整个生存期可以嵌入 **子生存期**

       优点:

       1. 各阶段无明显界限, 开发人员可以 **同步进行**
       2. 提高开发效率 **节省开发时间**

       缺点:

       1. 需要 大量开发人员
       2. 不利于 **项目管理**
       3. 需要严格管理 **文档和文档变更**

       **智能模型**

       基于"**知识的软件开发模型**", 把 **瀑布模型**,和 **专家系统**结合在一起, 利用专家系统来帮助开发人员工作

       **V模型**

       v模型是 **瀑布模型**的变种, 反应 **测试活动**和 **分析和设计**的关系.

  ## 软件开发方法

  1. ### **结构化方法**

     以 **数据流图DFD未工具** ,实现问题控件即 **需求的描述**, 

     以 **数据流/数据变换** 考虑, 从这个来描述 **系统的状况**

     (如果系统不是数据流为主干, 则数据流图不是十分有效)

  2. ### **面向数据结构的软件开发方法**

     从 **输入/输出的数据结构(顺序/选择/重复)**入手, 到处 **程序框架结构**, 补充其他 **细节**, 从而得到完整的程序结构图

     对 **输入/输出数据结构明确**的 **中小**系统特别有效, 也可以和其他方法结合, 用于 **模块的详细设计**

  3. ### **面向问题的分析方法**

     从 **输入/输出数据结构** 中到处 **基本处理框**, 分析 **先后关系**, 指导画出整个系统的PAD(problem analysis diagram) 问题分析图

     考虑输入/输出数据结构,使用 **PAD图**, 这是一种 **二位树**, 结构图, 是目前最好的详细设计表示方法之一

     由于 **输入/输出数据结构和整个系统之间存在鸿沟**, 这一方法, **只使用于小型问题**

  4. ### **原型化开发方法**

     以5个阶段组成 1. 确定用户需求 2.开发原始模型 3. 让用户使用原型 4. 修改原型 5. 判定原型完成情况, 满足则提交文档 交付使用

     使用于用户 **需求不清/业务理论不确定/需求经常变化的情况**,系统 **规模不是很大且不太复杂**用这种方法

  5. ### **面向对象的软件开发方法**

     从 **客观存在的事**来构造软件系统, 在系统中尽可能运用人了的 **自然思维方式**

     采用自底向上的归纳, 自顶向下解决方法, 建立对象模型 能 **真正反映用户需求,而且系统可维护性大大改善**

  6. ### **可视化开发方法**

     表现在两个方面: 1. 面向对象的思想, 引入 **控件** 和 **事件驱动** 2. 进行 **界面绘制工作**, 再 **基于事件编写程序代码**

     - 在 **编程**上使用可视化, 而不是在 **系统分析和设计上**使用可视化方法

## 面对对象开发方法

### 思想

客观世界由对象组成, 有 **内部状态 和 运动规律**, 不同对象 **相互作用和联系**构成不同的系统

面向对象 是从 **对象** 来构件软件系统, 尽量运用用 **自然思维方式**

### 基础知识:

一. **对象**: 独立的 **客观事务**, 有 **属性(对象的静态特征)和操作(类似方法,对属性的行为服务, 是对象的动态特征)**

OOA:面对对象分析

OOD: 面向对象设计

OOP:面向对象编程

二. **类**:

1. 类是对象之上的 **抽象**
2. 类是具有 **相同属性和方法**的一组对象的 **概念描述**
3. 一个类包含的 **属性数据**和 **操作方法**描述了一组对象的共同属性和行为



- 对象是类的具体化,是类的实例
- 每一个对象都属于某个类
- 类是创建对象的模板, 从同一个类实例化的每个对象具有相同的结构和行为



三. **封装:**

- 封装是屏蔽技术, 用户只能看见 **对外提供的服务**, 对象内部实现对用户是隐蔽的

- OO中, 类是一个完备的 **封装体** , 封装 对外提供接口, 可以一些属性和操作, 具体实现是不可见的

  好处:(设计者和使用者分离)

  - 设计者: 类的设计/数据结构和实现算法
  - 使用者: 操作功能于调用方法简单

四. **继承:**是类的基本管理,属于 **层次关系**, 不同类 **共享属性和操作**的一种机制

- 父类定义子类的公共属性和操作
- 子类除自己的属性和操作, 可以继承父类的属性和操作
- 子类可以对父类中的操作重新定

五. **多态:**不同的对象,收到 **同一信息**, 产生 **不同的结果**

- 同一种方法, 有不同的表现形同, 即 **不同的实现**

好处: 允许每个对象用适合自身的方式响应共同的消息

-  **重写** 是父类和子类 父子类**多态性**的表现,

- **重载** 是一个类中 **多个函数,方法名相同**,但是参数类型不同,返回数据不同, 构造出不同的行为, 重载是一个类中多态性的表现

六. **消息:** 对象发出的 **服务请求(对象间的交互手段)**

- 一个对象向另一个对象发消息请求某项服务, 接收消息对象响应,做出反应并把 **操作结果**返回请求的对象
- 发送一条消息要包含 **对象名, 方法名, 方法的参数值**(类似函数调用)

七. **关联**: 是对象之间的一种 **引用关系**

 一个对象去用另一个对象的服务(如人用pc)

- 特殊的关联1: **聚合关系**: 表示一个 **整体类**和 **部分类**的关系(如玩家和团队), 成员是整体的一部分,但是**成员对象可以脱离整体对象独立存在**

  带空心菱形的直线表示

- 特殊的关联2: **组合关系:**表示整体和部分的关系, 但是组合关系中部分和整体具有 **统一的生命周期**,一旦整体不存在, 那么部分对象也不存在, 同生共死的关系(如桌子和桌面/桌腿)

  带实心菱形的直线表示

八. **复用:**重复使用

- 分为 **共享/复制/改造**
- 例如程序员在 **可复用部件库**找到子程序, 模块或者段落等 **修改复用**



- **面向对象开发方法**起源于**面向对象编程**(20世纪8-90年代)包括5个阶段:
  1. OOA面向对象分析
  2. OOD面向对象设计
  3. OOI面向对象实现
  4. OOT面向对象测试
  5. OOSM面向对象维护

- 面向对象开发方法有5个:

  1. Coad Yourdon方法

     Coad Yourdon方法区分了面向对象分析（OOA） 和面向对象设计（OOD）

  2. Booch方法

     - Booch方法提出了面向对象的四个模型：**逻辑视 图、物理视图**及其对应的**静态和动态语义**

     - 是**UML的主要来源**

  3. OMT方法:对象建模技术

     - 覆盖了开发全过程, 提供了三种模型 **对象模型/动态模型/功能模型**
     - 总结: **谁在什么事件干了什么事**

     1. 对象模型强调"对谁做"
     2. 动态模型强调"何时做"
     3. 功能模型强调 "做什么"

  4. OOSE面向对象软件工程

     **OOSE方法**由**用例模型、域对象模型、分析模型、 设计模型、实现模型和测试模型**组成。

  5. RUP 统一软件开发过程

     RUP 是**UML的创始者**在创建UML的同时提出的一 种**面向对象的软件开发过程。**

     RUP的**6个开发核心过程工作流**:

     1. 业务建模
     2. 需求分析
     3. 系统分析与设计
     4. 实现
     5. 测试
     6. 系统配置。

     RUP的3个软件开发核心支持工作流:

     1. 配置变更管理
     2. 项目管理
     3. 环境

     RUP的4个连续阶段:

     1. 初始阶段
     2. 细化阶段
     3. 构建阶段
     4. 交付阶段

  ## 面向对象软件开发

  ### 1.可行性分析(可选)

  ​	技术先进性/经济合理性/条件可行性

  2. ### 需求分析和面向对象分析(OOA)

     - **需求分析**强调对问题需求的调查, 功能调查
     - 需求分析阶段包括人们如何使用情节和场景, 建立 **业务模型**
     - 使用 **用例图**
     - 对领域对象的调查分析
     - 识别所有对象, 建立 **概念对象模型**
     - 使用UML图: **用例图/类图/对象图/顺序图/通信图/状态图/活动图**

  3. ### 面向对象设计(OOD)

     - 对分析结果的扩充, **强调满足需求概念上的解决方案**
     - 是一个 **反复迭代**的过程
     - UML图有: 类图/对象图/包图/顺序图/通信图/状态图/活动图/构件图/配置图

  4. ### 面向对象实现(OOI)

     - 设计的 **类** 转换成 **面向对象的代码**
     - 编码遵守 **编程规则**
     - 采用 **软件复用**技术

  5. ### 面向对象测试和维护(OOT和OOSM)

     - 发现代码错误, 测试包括一些 **测试用例的设计**

     - 每个 **测试用例**要指明 **要做什么/使用哪些数据/期望结果**,测试结构记录在测试报告中

  ### 总结:

  特点:

  1. 和人类习惯思维一致
  2. 稳定性好
  3. 可复用性好
  4. 容易开发大型产品
  5. 易于维护

  **先进机制**表现在:

  1. 封装
  2. 抽象
  3. 继承
  4. 多态

  **目前面向对象方法是当前软件工程中最有效/最流行的方法**





# UML概述

## 为什么要建模

1. 软件复杂度增大
2. 开发人员要沟通
3. 提供模型后期文档

## UML是什么

- 第一个统一的建模语言,统一的符号体系,

- 认可的标准, 第三代面向对象开发方法, 是一种 **面向对象可视化通用语言** 提供  **UML图**作为标准

- 适用于 各个阶段

## UML体系

1. 基本构造块

   1. **事物**: UML的基本构成元素, 模型中 **首要成分抽象**

      - 结构事物: UML的静态部分, 用于对概念或者物理元素建模(包括类/接口/对象/构件/节点/制品/用例/协作)
      - 行为事物:UML的动态部分, 描述跨时空和时间行为(交互/状态机)
      - 分组事物: UML的组织部分, 描述事物的 **组织结构**(包)
      - 注释事物: UML的解释部分,对元素进行说明/解释(注解/)

   2. **关系:**把事物组合在一起, 说明多个 **模型元素**的相关性

      - 关联关系:一种结构关系, 指明事物对象的联系(**双向关联**,**单向关联**(箭线表示)**,自关联**(存在类本身的调用)) 特殊关系**1:聚合**(整体和部分, 可拆分, 生命周期不一致, 空心棱形直线) 特殊关系**2:组合**(生命周期一致, 实心棱形直线表示)
      - 依赖关系:A类变化引起B类变化, 改变事物影响到其他事物,体现在类的方法使用另外一个类的对象作为参数(例如司机使用车类的车作为驾驶的参数)(带箭头的虚线表示,指向被使用的一方)(有三种情况:1. A是B的方法的参数 2.A是B的局部变量 3. A向B发消息,影响B变化)
      - 实现关系: 实现接口/类/组件 将方法的定义和实现分开, 利于代码维护(用带空心三角形的虚线表示)
      - 泛化关系:父子类继承, (带空心三角形的实现表示)

   3. ### **图**:**事物**和**关系**的 可视化表现

      - 13种: 主要包括 **结构图**和 **行为图**

      - 结构图:系统内部, 静态结构

        1. 类图:一般类/抽象类(斜体字表示)/接口(尖括号表明是接口或者直接一个圆圈表示)

        2. 对象图:只是描述对象名和属性,不描述方法, 要写出数据类型和值, 对象名前面 还有冒号

        3. 组件图(构件图):特点在于 **封装性**和 **可复用性**, 描述系统存在构件和构件如何通过接口连接的系统,要有构件名称, 构件标识<<component>> 和构件图标

        4. 部署图:一组 **节点**和他们的关系, 描述硬件拓扑结构, 也可描述制品如何在节点上部署和连接(节点是眼见, 制品是软件或者信息如:文档/文件)

        5. 组合结构图:类或协作的内部结构建模(组合结构图可以使用类图/对象图/组件图/种的图元,也可有自己的建模元素)

        6. 包图(模型元素的分组管理, 应该高内聚低耦合, 包图可以包含多个类和子包)

           

      - 行为图:描述系统动态模型和对象的交互关系(用例图/活动图/交互图(又分为顺序图/通信图/交互概览图/定时图)/状态机图)

        1. 用例图: 描述系统对外可见的 **需求或功能** 一个用例代表系统执行的 **一组动作**, 用例图从用户角度描述 **系统的行为和特征**, 指明系统各项功能的参与者, 用例图刻画系统包含哪些用例, 用例之间和参与者的关系(用例用实现椭圆表示,交互用实线,包含关系用虚线表示(带<<include>>,抽象出来基用例和子用例来表示,)) **参与者**可分为: 1. 人 2. 设备 3. 外部系统

           

        2. 活动图: 类似流程图, 描述用例进行的活动, 展示一组动作, 动作到动作的顺序流或分支流, 适合 **内部系统逻辑**, 否则适合用状态机图(实心圆开始, 十字x圆结束, 圆角矩形表示活动, 棱形表示分支选择, 分叉和合并成对出现, 矩形表示对象, 可以加入泳道)

        3. 交互图: 表示交互, 对象和对象之间传递消息, 强调消息,通过消息之间进行交互

           - 顺序图: 对象之间的信息传递和信息传递时间(类似对象和对象函数调用, 有生命线,从上到下表明顺序)消息有4种: 1. 同步消息(发送后暂停等待应答,实线实心三角) 2. 返回消息(消息接收者返回的消息,虚线箭头) 3.异步消息(发送后不暂停,,实线半边箭头) 4.简单消息(实线箭头)

           - 通信图: 关注交互对象连接组成的结构, 消息和方向附属于对象连接, 通过编号表示消息顺序

             通信图和顺序图可以相互转化, 通信图强调对象的关系(空间关系,时间顺序必须从顺序号获得)

           - 交互概览图: 可以看成顺序图的变体,用活动来补充顺序图, 在草图种更适用, 线通过活动图对流程建模, 再对关键节点细化, 顺序图表示对象的控制流, 注意: 对于大系统, 交互概览图不是很好, 会让模型可读性大大降低
           - 定时图:带有数字刻度的时间轴精确描述消息的顺序, 不像顺序图那样只是制定消息的相对顺序
           - 定时图可以 可视化表示每条生命线的状态变化(用生命线的"凹下凸起"表示对象状态变化), 对象交互也是用消息, 带箭头的线表示 注意: 1.定时图用于建模 **实时系统** **嵌入式系统**非常高效, 2. 在大部分应用系统不需要, 但是局部对象可能需要用定时图描述

        4. 状态机图:状态机图对一个单独对象行为建模, 知名整个生命周期内, 响应不同时间, 执行时间的顺序,(实心圆开始, 双线圆终止, 圆角矩形表示状态)

      #### 图的应用

      - 需求分析

        用例图/活动图

      - 系统分析设计

        类图/对象图/包图/顺序图/通信图/活动图/状态机图

      - 实现

        类图/活动图/交互图

      - 集成和交付

        组件图(构件图)/包图/部署图

      - 测试 

        单元测试:  类图/类说明书 集成测试: 部署图/通信图 确认测试: 用例图

      UML2.0的特点: 用例驱动

2. 公共机制: 为了让模型更加一致性, 定义4种公共机制

   1. 规格描述
      - 用于对构造块语法语义进行文字描述(图形对系统可视化, 详述说明系统细节)
   2. 修饰
      - 不同展示场合选择不同表达方式, 如类有长格式和短格式(不用把所有内容表示出来用来让系统更加简洁易懂), 
   3. 通用划分
      - 有一些共同划分方法,比如 **类和对象的划分, **比如类和对象划分, 接口和实现划分, 类型(实体种类)和角色(语境含义)划分
   4. 拓展机制
      - 让语言有更好的 **适应性**, 让UML 根据自己需求自定义一些事物
        1. 衍型:stereoytpe: 1.模型元素:UML模型最基本单位(基元素/衍型元素) 2. 基元素(类/对象/包/消息等) 3.衍型元素:(基元素上自定义的模型元素) 衍型元素用<<>>中表示
        2. 标记值:UML模型元素的特性拓展, 用在模型元素规约中 **创建新消息**, 用{}括起来的字符串表示, 放在模型元素里面
        3. 约束:UML对 **语义的拓展**,用于增加新规则或者修改已有的规则, 约束用 {}包起来的字符串表示, 放在关联元素附近或通过依赖关系连接响应元素

3. 构架(五大视图)

   1. 用例视图

      - 系统外部执行者的角度看到或者需要的系统功能(用例图表示, 动态用交互图/状态机图/活动图表示)

        

   2. 设计视图

      - 描述系统设计特征
      - 静态用类图/对象图, 动态用交互图/状态机图/活动图

   3. 交互视图

      - 描述系统内部不同部分的控制流
      - 静态用类图/对象图, 动态用交互图/状态机图/活动图 
      - 和设计视图相同, 但是重点在于系统主动类和他们之间的流动的消息

   4. 实现视图(系统的组件视图)

      - 表示系统实现特征

      - 静态用构件图 , 动态用交互图/状态机图/活动图表示

   5. 部署视图

      - 描述系统物理配置特征
      - 静态用部署图表示, 动态用交互图/状态机图/活动图表示

   ## 需求分析和用例建模

   - 需求分析的正确方法为 **调查**

     - 初步调查: 可行性分析, 投入少量人力分析调查
     - 详细调查: 系统分析阶段, 投入大量人力, 详细调查

   - 调查策略

     1. 了解文档/表格/报告/文件
     2. 设计分发调查表, 澄清没理解的问题
     3. 面谈验证澄清问题
     4. 没理解的功能需求和需要被验证的需求,**构造获取原型**

     注意: 应该在面谈之前获取尽可能多的信息

   ### 需求分析特点

   1. 用户和开发人员难 **交流**
   2. 用户 **需求容易改变**
   3. 系统变更代价呈非线性增长

   ### 建立用例模型

   1. 确定参与者和参与者的关系
   2. 绘制用例图
   3. 用例审查
   4. 编写用例补充说明文档(用例名称/参与者/前置条件/后置条件/基本事件流/备用事件流/备用事件流/异常事件流)



### 类的版型

1. 边界类(展现层):用空心圆加T型线表示, 或者类上加上<<boundary>>
2. 控制类(逻辑层):首尾相接的圆或者类上加<<control>>
3. 实体类(持久层):圆加下划线,或者类上加<<entity>>



### 类图的抽象层次

1. 概念层类图:领域概念, 包括类名, 不包括细节
2. 说明层类图:不针具体语言, 包含一些细节
3. 实现层类图:针对具体语言, 考虑类的实现细节

### 类的关系:

1. 关联

   有6种修饰:

   1. 名称:关联上写字, 实心三角指向方向
   2. 角色: 关联端点写上角色名
   3. 多重性:一对多多对一等
   4. 导航性:指向哪边, 单向关联双向关联等
   5. 聚合:  可拆分
   6. 组合 :不可拆分

2. 依赖

3. 泛化

4. 实现